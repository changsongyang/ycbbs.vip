### 1.请看如下代码 
```java
class Person { 
	private int a;
	public int change(int m){return m;} 
}

public class Teacher extends Person{ 
	public int b;
	public static void main(String arg[]){ 
		Person p = new Person(); 
		Teacher t = new Teacher(); 
		int i; 
		// point x 
	}
}
```
下面哪些放在// point x?行是正确的？ ()
A， i = m; 
B， i = b; 
C， i = p.a; 
D， i = p.change(3); 
E， i = t.b;

答案：D
【解析】本题考查类的声明。选项A中m没有被声明过，不能使用；选项B中虽然b是类Teacher的public成员变量，但在静态方法中，不能使用类中的非静态成员；选项C中a是类Person的private成员，在类外不能直接引用；选项D中change(intm)方法是pubtic方法，并且返回一个int型值，可以通过类的实例变量P引用并赋值给一个int型变量。

### 2.method(){?}的重载函数？（）
A.public void method( int m){?}
B.public int method(){?}
C.public void method2(){?}
D.public int method(int m，float f ){?}
答案：同第三题

### 3.下面那几个函数是public void method(){̷}的重载函数？（）
A.public void method( int m){̷}
B.public int method(){̷}
C.public void method2(){̷}
D.public int method(int m，float f ){̷}
答案：A D
解析：
重载就是方法名一样(必须的)，里面执行的内容不一样，但是呢，又出现一个问题，你写的两个或者多个方法要能让JVM(JAVA 虚拟机)认识是唯一的，所以，这里就和返回的类型无关了，因为如果返回类型不一样，其他都一样的话，那JVM是不知道到底是调用哪个方法的。所以方法名一样，入参的类型，个数，顺序（术语：方法的签名）只要有一个不同就是方法的重载了。

### 4.下面的哪些声明是合法的？（ ）
A.long 1 = 499
B.int i = 4L
C.float f =1.1
D.double d = 34.4
答案：AD
解析：
B.4L应该是long类型的写法，
C.1.1是double类型 ，float f=1.1f是正确写法

### 5.问：Java 匿名内部类在使用时如何初始化吗？
解析：匿名内部类无法通过构造方法初始化，所以我们只能通过构造代码块进行初始化。

### 6问：开发中使用 Java 匿名内部类有哪些注意事项（经验）？
答：常见的注意事项如下。
使用匿名内部类时必须是继承一个类或实现一个接口（二者不可兼得且只能继承一个类或者实现一个接口）。
匿名内部类中是不能定义构造函数的，如需初始化可以通过构造代码块处理。
匿名内部类中不能存在任何的静态成员变量和静态方法。
匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
匿名内部类不能是抽象类，必须要实现继承的类或者实现接口的所有抽象方法。

### 7.问：请简单谈谈 TreeMap 与 HashMap 的区别？
答：TreeMap 实现了 SortMap 接口，其能够根据键排序，默认是按键的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时得到的记录是排过序的，所以在插入和删除操作上会有些性能损耗，TreeMap 的键和值都不能为空，其为非并发安全 Map，此外 TreeMap 基于红黑树实现。

HashMap 是最常用的 Map，其基于哈希散列表实现，主要根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度，当用 Iterator 遍历 HashMap 时得到的记录顺序是随机的，HashMap 只允键值均为空，其为非并发安全 Map。

所以一般情况下我们选用 HashMap，因为 HashMap 的键值对在取出时是随机的，其依据键的 hashCode 值和键的 equals 方法存取数据，具有很快的访问速度，所以在 Map 中插入、删除及索引元素时其是效率最高的实现。而 TreeMap 取出来的是排序后的键值对，所以效率会低点。

### 8.问：说说 HashSet 与 HashMap 的区别？
答：从实质上说 HashSet 的实现实质就是一个 Map 对象的包装，只是 Map 的 value 为 Object 固定对象，Set 只利用了 Map 的 key 而已。具体区别来说如下：
HashMap 实现了 Map 接口，而 HashSet 实现了 Set 接口。
HashMap 储存键值对，而 HashSet 仅仅存储对象。
HashMap 使用 put 方法将元素放入 Map 中，而 HashSet 使用 add 方法将元素放入 Set 中。
HashMap 中使用键对象来计算 hashcode 值，而 HashSet 使用成员对象来计算 hashcode 值。

### 9.问：简单说说什么是二叉树？什么是完全二叉树？什么是满二叉树？什么是排序二叉树？
二叉树是一种从上往下分叉的一种数据结构，其每个节点最多有两个孩子节点，一左一右，左边的称为左孩子，右边的称为右孩子。
完全二叉树是普通二叉树除最后一层外，在每一层上的结点数均达到最大值，在最后一层上只缺少右边若干结点的二叉树
满二叉树是普通二叉树中的每个结点恰好有两个孩子结点且所有叶子结点都在同一层的二叉树
若普通二叉树每个节点满足左子树所有节点值小于它的根节点值且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树

### 10.问：面向对象的三大特征是什么？请详细介绍他们各自的部分原理？
解答：

答：特征可以说有三种，继承、封装、多态，也可以说有四种，继承、封装、多态、抽象。

继承性是类的一种层次模型，其提供了一种明确表述共性的方法，对象的新类可以从现有的类中继承派生，类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。

封装性是把过程和数据包围起来，使得数据的访问只能通过已定义的接口，保证了对象被访问的隐私性和可靠性。

多态性是对象在不同时刻表现出来的多种状态，是一种编译时期状态和运行时期状态不一致的现象，多态性包括参数化多态性和包含多态性。

抽象性是指对一类事物的高度提炼以得到共同的共性部分，抽象不需要了解全部细节，而只是一种通用的描述约束，抽象可以是过程抽象或者数据抽象。


希望读者能够给小编留言，也可以点击[此处扫下面二维码关注微信公众号](https://www.ycbbs.vip/?p=28 "此处扫下面二维码关注微信公众号")